import os
import sim_launch_py.utilities as util
import numpy as np

class Project():
    """
    The project class that stores and manage all the information and methods.

    Attributes:
    - name : name of the project. This defines the directory where the project will be stored and most of path variables. 
    - project_path : absolute path of the project. The name of the directory is derived from the name of the project.
    - systems_path : directory where the data of the simulated systems are stored. This is the parent directory of the systems. 
    - topology_path : directory where the topology files (.top and .itp) of the molecules used in the project are stored and retrieved to be used in each system.
    - init_struct_path : path where initial structures of the molecules used in the project are stored and retrieved to be used in each system.
    - mdp_path : path where default .mdp input files for gromacs are stored.
    - pickle_path : path where the project is saved in .pkl format.
    - job_script_path : path where the template files for submission scripts are stored.
    - systems : list of System() objects in the project.
    - molecules : list of Molecule() objects in the project.
    - gromacs : path to gromacs binary
    - ambertools : path to ambertools binaries directory
 
    Methods:
    - help() : print the help for this class.
    - add_molecule(self, name: str, resname='UNK', structure=None) : add and initialize a Molecule() object to the Project() object.
    - add_system(self,name: str) : add and initialize System() to the Project()
    - new_project(name=None, path=None, overwrite=False) : create new Project()
    - save(self) : save Project() in Project().pickle_path
    - load_project(project_folder: str) : load Project() stored in project_folde/.multisim.pkl. 
    - write_sub_command(self,scriptname: str,hpc_system: str, template: str): write job submission/run scripts for the given HPC system for each System() and a global bash script to call all the job scripts.
    

     #### TODO METHODS ####
    - change_project_path(self,newpath: str) : when implemented, it will allow to copy the project to a new path and
change all the pertinent path attributes.

    """

    def __init__(self,name=None, path=None):
        """Project Class Constructor

        Args:
            name (str, optional): Project name. Defaults to None.
            path (str, optional): Project path. Defaults to None.
        """
        path=os.path.abspath(path)

        if path.rstrip().endswith("/"):
            path = path.rstrip()[:-1]
        
        self._name=name
        self._project_path=os.path.abspath(path)
        self._systems_path="{}/Systems".format(path)
        self._topology_path="{}/Topologies".format(path)
        self._init_struct_path="{}/Initial_structures".format(path)
        self._mdp_path="{}/mdp".format(path)        
        self._pickle_path="{}/.multisim.pkl".format(path)
        self._job_script_path=None
        #self._logfile="{}/project.log".format(path)
        self._systems=list()
        self._molecules=list()        
        self._gromacs=None
        self._ambertools=None

        # look for gromacs and ambertools in the $PATH
        self._checkGromacs()
        self._checkAmberTools()
       
    @property
    def project_path(self):
        return self._project_path

    @property
    def mdp_path(self):
        return self._mdp_path

    @property
    def init_struct_path(self):
        return self._init_struct_path

    @property
    def topology_path(self):
        return self._topology_path

    @property
    def job_script_path(self):
        return self._job_script_path

    @property
    def name(self):
        return self._name

    @property
    def systems(self):
        return self._systems
    
    @property
    def molecules(self):
        return self._molecules

    @property
    def logfile(self):
        return self._logfile

    @property
    def systems_path(self):
        return self._systems_path

    @property
    def gromacs(self):
        return self._gromacs

    @property
    def ambertools(self):
        return self._ambertools
   
    @job_script_path.setter
    def job_script_path(self,sp):
        self._job_script_path=sp

    @logfile.setter
    def logfile(self,log):
        self._logfile=log

    @systems_path.setter
    def systems_path(self,p):
        self._systems_path=p

    @gromacs.setter
    def gromacs(self,gmx):
        self._gromacs=gmx

    @ambertools.setter
    def ambertools(self,amber):
        self._ambertools=amber
        
    @staticmethod
    def help():
        print("""Attributes:
    - name : name of the project. This defines the directory where the project will be stored and most of path variables. 
    - project_path : absolute path of the project. The name of the directory is derived from the name of the project.
    - systems_path : directory where the data of the simulated systems are stored. This is the parent directory of the systems. 
    - topology_path : directory where the topology files (.top and .itp) of the molecules used in the project are stored and retrieved to be used in each system.
    - init_struct_path : path where initial structures of the molecules used in the project are stored and retrieved to be used in each system.
    - mdp_path : path where default .mdp input files for gromacs are stored.
    - pickle_path : path where the project is saved in .pkl format.
    - job_script_path : path where the template files for submission scripts are stored.
    - systems : list of System() in the project.
    - molecules : list of Molecule() in the project.
    - gromacs : path to gromacs binary
    - ambertools : path to ambertools binaries directory
     
    Methods:
    - help() : print the help for this class.
    - add_molecule(self,name=None,resname='UNK', structure=None) : add and initialize Molecule() to the Project()
    - add_system(self,name=None) : add and initialize System() to the Project()
    - new_project(name=None, path=None, overwrite=False) : create new Project()
    - save(self) : save Project() in Project().pickle_path
    - load_project(project_folder: str) : load Project() stored in project_folde/.multisim.pkl. 
    - write_sub_command(self,scriptname: str,hpc_system: str, template: str): write job submission/run scripts for the given HPC system for each System() and a global bash script to call all the job scripts.
    

     #### TODO METHODS ####
    - change_project_path(self, newpath: str) : when implemented, it will allow to copy the project to a new path and change all the pertinent path attributes.""")

    def add_molecule(self, name: str, resname='UNK', structure=None):
        """Add molecule to project

        Args:
            name (str): molecule name. Defaults to None.
            resname (str, optional): residue name. Defaults to 'UNK'.
            structure (str, optional): molecular structure file. Defaults to None.
        Returns: 
            newmolecule (object): new molecule.
        """

        # restrict resname to a string of capital letters of length 3
        resname=resname.upper()[0:3]
        
        import shutil
        for mol in self._molecules:
            if name == mol._name:                
                print("Error: a molecule with name {} ({}) already exists in the project!".format(name,resname))
                exit()

        newmolecule=Molecule(name,resname=resname,structure=os.path.abspath(structure))
        
        self._molecules.append(newmolecule)        
        shutil.copy(structure, self._init_struct_path)

        return newmolecule

    def add_system(self, name: str):
        """Add system to project

        Args:
            name (str): system name.
        Returns:
            newsystem (object): new system.
        """

        from sim_launch_py.utilities import create
        
        for sys in self._systems:
            if name==sys.name:
                print("Error: System {} already exists!".format(name))
                exit()

        syspath=self._systems_path+'/'+name
        if os.path.isdir(syspath) is False:
            create(syspath, arg_type='dir')
        
        newsystem=System(name=name,path=syspath,gromacs=self._gromacs)
        self._systems.append(newsystem)

        

        return newsystem
       

    def new_project(name: str, path: str, overwrite=False):
        """Add new project

        Args:
            name (str): Project Name.
            path (str): Project path.
            overwrite (bool, optional): Overwrite previous project? Defaults to False.

        Returns:
            nproject (object): new project.
        """
        
        from sim_launch_py.utilities import create
        
        path=os.path.abspath(path)
        nproject = Project(path=path, name=name)

        if not os.path.exists(nproject._project_path):
            print("New Project: {}".format(nproject._name))
            print("=" * 100)
            create(nproject._project_path, arg_type='dir', backup=False)
        else:
            if overwrite:
                print("New Project: {}".format(nproject._name))
                print("=" * 100)
                create(nproject._project_path, arg_type='dir', backup=False)
            else:
                print("Error: Folder already exists.\n "
                      "You can change directory name or overwrite with 'overwrite=True' "
                      "(everything inside will be deleted)")
                exit()
        create(nproject._systems_path, arg_type='dir')
        create(nproject._init_struct_path, arg_type='dir')
        create(nproject._topology_path, arg_type='dir')
        create(nproject._mdp_path, arg_type='dir')
        
        return nproject


    def save(self):
        """
        Save project to project folder.
        """
        print("Saving Project...", end="")
        import pickle
        import os
        if os.path.exists(self._pickle_path):
            os.rename(self._pickle_path, self._project_path+ "/.multisim.bck.pkl")
        with open(self._pickle_path, "wb") as file_pickle:
            pickle.dump(self, file_pickle)
        print("done")



    def load_project(project_folder: str): 
        """Load an existing project. The Project object is saved in the project directory every time the command Project.save()
        is used.
        
        Args:
           project_folder (str): location of the project to be loaded.

        Returns:
           project (object): loaded project.
        """

        import pickle
        project_folder = os.path.realpath(project_folder)
        file_pickle = project_folder + "/.multisim.pkl"
        if os.path.exists(file_pickle):
            project = pickle.load(open(file_pickle, "rb"))
            print("Loading Project Name: {}\n".format(project._name))
            if os.path.realpath(project._project_path) != project_folder:
                project.projecy_path = project_folder
            return project
        else:
            print("No project found in '{}'. Use the 'Project.new_project' module to create a new project."
                  "".format(project_folder))

    #def change_project_path(self, newpath: str):
    #    """Change the path of the project and all the relevant paths in the objects in the project (systems, simulations...)
    #
    #    This involves changing all the relevant variables (e.g., project_path, systems_path, topology_path...), 
    #    and copying the existing files to the new location. 
    #    """
    #
    #    oldpath=self.project_path        
    #    self._project_path=os.path.abspath(path)

        

    
    def write_sub_command(self,scriptname: str,system='myriad', template=None):
        """For each system Write a script to run the simulations and write a global bash script to initiate all systems.

        Args:
           scriptname (str): name of the global bash script.
           system (str, optional): type of script for the systems. Supported are 'bash' and 'myriad' (GridEngine format on Myriad cluster at UCL). Defaults to 'myriad'.
           template (str, optional): custom template to be used for the local script. Defaults to None. 
        """
        import shutil
        recognised_systems=['bash','myriad']

        scriptname=self.project_path+'/'+scriptname
        
        if system=='bash':
            for sys in self.systems:
                print("Sorry... for the moment this doesn't do anything...")                

        elif system=='myriad':

            if template==None:
                template=self.job_script_path+'/myriad.job'
            else:
                template=os.path.abspath(template)

            filename=os.path.basename(template)

            for sys in self.systems:
                shutil.copy(template,sys.path)
                with open(sys.path+'/'+filename,'a') as f:
                    f.write("\n\n")
                    for s in sys.simulations:
                        if s.run:
                            f.write("# {}\n".format(s.name))
                            f.write(s.bash_command+'\n\n')
                sys.run_command='qsub -N {0} {1}\n'.format(self.name+'_'+sys.name, filename)

            with open(scriptname,'w') as f:
                f.write("#!/bin/bash\n\n")
                for sys in self.systems:
                    f.write("cd {}\n".format(sys.path))
                    f.write(sys.run_command)
                    f.write("cd {}\n\n".format(self.project_path))

        else:
            print("ERROR: Type of submission script '{}' not recognized. acceptable values are: ".format(system))
            for rs in recognised_systems:
                print("- {}".format(rs))
            exit()

    def _checkGromacs(self):
        """Look for Gromacs binary and add it to the project.
           This method looks for standard names of gromacs binaries (i.e. 'gmx' and 'gmx_mpi'). If either of these is not found,
           it will prompt the user to input manually the absolute path of the gromacs executable.
           The value of the attribute is the absolute path of the binary (/path/to/gmx or /path/to/gmx_mpi or /path/to/gmx_bin_custom_name).
        """
        import shutil

        if self.gromacs is None:
            if shutil.which('gmx') is not None:
                self.gromacs=shutil.which('gmx')
            elif shutil.which('gmx_mpi') is not None:
                self.gromacs=shutil.which('gmx_mpi')
            else:
                self.gromacs=input("I couldn't find gromacs command, you can add it manually: ")
        elif self.gromacs=='':
            exit("Error: gromacs command is not in the PATH and is not added to the project")

    def _checkAmberTools(self):
        """Look for AmberTools binaries directory and add it to the project.
           This method looks for the antechamber binary. If it is not found, it will prompt the user to input manually the absolute path of the ambertools binaries directory.
           The value of the attribute is the absolute path of the directory (/path/to/bin).
        """
        
        import shutil
        if self.ambertools is None:
            if shutil.which('antechamber') is not None:
                self.ambertools=shutil.which('antechamber')
            else:
                self.ambertools=input("I couldn't find ambertools binaries directory, you can add it manually: ")
        elif self.ambertools=='':
            exit("Error: ambertools binaries is not in the PATH and is not added to the project")

        
class System():
    """
    The system class that stores and manage all the information and methods.

    Attributes:
    - name : name of the system. This is used to create the directory of the system.
    - path : absolute path of the system.
    - molecules : list of Molecule() objects belonging to the system.
    - box : size of the box (of the initial configuration).
    - boxshape : shape of the simulation box.
    - simulations : list of Simulation() objects of the system.
    - run_command : command lines to be used to run the simulations.
    - gromacs : gromacs binary path, inherited from the Project(). 
    - composition : composition of the system. Order of values is the same of the order in self.molecules.
    - atoms : list of Atom() objects in the system.
    - natoms : total numer of atoms in the systems.

    Methods:
    - help() : print the help for this class
    - add_molecule(self, name: str, moltype=None, knownmolecules=None) : add species to the system.
    - add_box(self, box_side: float, shape='cubic') : create simulation box.
    - createSolventBox(self, solvent: object, output_structure="solvent_box.pdb", density=None, nmols=None): add solvent molecules to the simulation box.  
    - insertSolute(self, solute: object, solvent: object, solvent_box="solvent_box.pdb", concentration=0, output_structure="start.pdb"): add solute molecules to the box and remove excess solvent molecules.
    - writeTop(self, atomtypes_path: str, *molecules: objects): write the topology file for the system in gromacs format.
    - add_simulation(self, simtype: str, mdrun_options='', mdp='', print_bash=True, name='',maxwarn=0, start_coord='',gmxbin=''): add simulation to the system.
    - print_command(self, bash_file): print the bash script file to run the simulations.
   
    """

    def __init__(self,name,path=None,gromacs=None):
        """System Class Constructor

        Args:
            name (str): Systen name
            path (str, optional): System path. Defaults to None.
            gromacs (str, optional): Gromacs binary name. Defaults to None.
        """

        self._name=name
        self._path=path
        self._molecules=list()
        #self._temperature=0
        self._box=list()
        self._boxshape=None
        self._simulations=list()
        self._run_command=None
        self._gromacs=gromacs
        self.composition=list()
        self._atoms=list()
        self._natoms=0        

    @property
    def name(self):
        return self._name

    @property
    def path(self):
        return self._path

    @property
    def molecules(self):
        return self._molecules

    #@property
    #def temperature(self):
    #    return self._temperature
    ##### temperature will be set in the simulation object

    @property
    def box(self):
        return self._box

    @property
    def boxshape(self):
        return self._boxshape

    @property
    def simulations(self):
        return self._simulations

    @property
    def run_command(self):
        return self._run_command

    @property
    def gromacs(self):
        return self._gromacs

    @property
    def atoms(self):
        return self._atoms

    @property
    def natoms(self):
        return self._natoms

    @gromacs.setter
    def gromacs(self,gmx):
        self._gromacs=gmx
    
    #@temperature.setter
    #def temperature(self,T):
    #    self._temperature=T
    ##### temperature will be set in the simulation object

    @natoms.setter
    def natoms(self,n):
        self._natoms=n

    @box.setter
    def box(self,box):
        self._box=box

    @boxshape.setter
    def boxshape(self,shape):
        self._boxshape=shape

    @run_command.setter
    def run_command(self,command):
        self._run_command=command

    @staticmethod
    def help():
        print("""Attributes:
    - name : name of the system. This is used to create the directory of the system.
    - path : absolute path of the system.
    - molecules : list of Molecule() objects belonging to the system.
    - box : size of the box (of the initial configuration).
    - boxshape : shape of the simulation box.
    - simulations : list of Simulation() objects of the system.
    - run_command : command lines to be used to run the simulations.
    - gromacs : gromacs binary path, inherited from the Project(). 
    - composition : composition of the system. Order of values is the same of the order in self.molecules.
    - atoms : list of Atom() objects in the system.
    - natoms : total numer of atoms in the systems.

Methods:
    - help() : print the help for this class
    - add_molecule(self, name: str, moltype=None, knownmolecules=None) : add species to the system.
    - add_box(self, box_side: float, shape='cubic') : create simulation box.
    - createSolventBox(self, solvent: object, output_structure="solvent_box.pdb", density=None, nmols=None): add solvent molecules to the simulation box.  
    - insertSolute(self, solute: object, solvent: object, solvent_box="solvent_box.pdb", concentration=0, output_structure="start.pdb"): add solute molecules to the box and remove excess solvent molecules.
    - writeTop(self, atomtypes_path: str, *molecules: objects): write the topology file for the system in gromacs format.
    - add_simulation(self, simtype: str, mdrun_options='', mdp='', print_bash=True, name='',maxwarn=0, start_coord='',gmxbin=''): add simulation to the system.
    - print_command(self, bash_file): print the bash script file to run the simulations.""")
    
    def add_molecule(self, name: str, input_structure: str, moltype=None, template=None, pdbfile=None, nmols=1, output_structure='conf.pdb'):
        """Add new molecule type to the system.

        Args:
           :param name (str): name of the molecule.
           :param input_structure (str): name of the starting structure file.
           :param moltype (str, optional): generic attribute of the molecule. Defaults to None.
           :param template (Molecule(), optional): molecule already present in the project to be used as template for the addition. Defaults to None.
           :param pdbfile (str, optional): PDB file from which the configuration is read. Defaults to None.
           :param nmols (int, optional): number of copies of the template molecule to be inserted. Defaults to 1.           
           :param output_structure (str, optional): name of the generated structure file. Defaults to conf.pdb.
        
        How to proceed:
        1) addition of pdb file to the available inputs - DONE
        2) check: if from pdb -> read pdb and add molecules and coordinates from the pdb - DONE
                  elif not from pdb -> read name of the known molecule and add new 
                                       coordinates. 
                                       When adding molecules in random positions, use gmx insert-molecules
                                       indicating the number of molecules to insert and creating the corresponding 
                                       objects with the new coordinates.
                                       When adding molecules in given positions, create the molecule object with
 				       the new coordinates. 
                   ***the idea is to generate from scratch a pdb used to start the simulations after
                      the wanted configuration has been defined***

        3) addition of a molecule object needs to trigger the creation of the following attributes:
                 - name
                 - resname
                 - list of atom names
                 - list of atom types
                 - number of atoms
                 - mass
                 - coordinates (may be empty)
                 - bond matrix (likely a NxN matrix of 0 and 1, where 1 is bound atoms, 0 not bound. Diagonal is 0) 
	n) to be considered: addition of a "molecule group", for molecules that share parameters (.itp files...)
                 
        


        """

        

        if pdbfile:
            # procedure here is:
            # 1) create a new molecule
            # 2) read the pdb file with a _loadfrompdb(pdbfile) function that returns:
            #	a) list of atoms
            #	b) list of coordinates
            #	c) bond matrix
            #	d) resname

            # check that pdbfile exists

            # get box info from pdb file
            f=open(pdbfile,'r')
            for line in f:
                if line.startswith('CRYST1'):
                    a=float(line[6:15])
                    b=float(line[15:24])
                    c=float(line[24:33])
                    alpha=float(line[33:40])
                    beta=float(line[40:47])
                    gamma=float(line[47:54])
                    self.box=[a/10,b/10,c/10,alpha,beta,gamma]   # sides in nm, angles in degrees

            # get molecules and coordinates from pdb file                        
            newmol=self._loadfrompdb(name,pdbfile)
            for m in newmol:
                self._molecules.append(m)

        elif not pdbfile and template:

            # In this case add to the system nmol molecules with gmx insert-molecules
            # The molecule needs to be known (i.e. added to the Project)
            # after gmx insert-molecules command a check that all needed molecules have been added is done
            # and new coordinates are read to create new molecule objects

            import subprocess

            output_structure=self.path+'/{}'.format(output_structure)
            result=subprocess.run("{0} insert-molecules -f {1} -ci {2} -nmol {3} -o {4}".format(self.gromacs,
                                                                                                input_structure,
                                                                                                template._structure_path,
                                                                                                nmols,
                                                                                                output_structure),stdout=subprocess.PIPE,stderr=subprocess.STDOUT, shell=True)

            # now check that all molecules have been inserted
            added_line=result.stdout.decode()[result.stdout.decode().find("Added "):result.stdout.decode().find("Added ")+result.stdout.decode()[result.stdout.decode().find("Added "):].find(')')+1]
            added=int(added_line.split()[1])
            if added != nmols:
                print("error! {}".format(added_line))
                exit()


            

            

        elif not pdbfile and not knownmolecules:
            print("Error: Couldn't add molecule {} to system {}. Molecule unknown.".format(name,self.name))
            exit()

        

    @staticmethod
    def _loadfrompdb(name: str, pdbfile: str ):
        """
        Taken and adapted from the method with the same name in PyPol by Nicholas Francia

        Load Molecule from a PDB file. If the pdb file contain the 'CONECT' keyword,
        bonds are taken from it. Alternatively, they can be generated with the 'atomtype' program.
	:param name: Name of the molecule
        :param pdbfile: Path of the PDB file
        :param include_atomtype: Include the identification of the atom types
        :return: Molecule() object
        """

        new_molecule = Molecule(name)
        molecules = list()
        
        # Open pdb file

        file_pdb = open(pdbfile)
        bonds_imported = False # this flag becomes True iff there is at least one CONECT line
        iline=0
        prev_mol=0
        for line in file_pdb:
            iline+=1
            # Import Molecular and Atom Properties
            if line.startswith("ATOM") or line.startswith("HETATM"):
                atom_index = int(line[6:11]) - 1
                atom_label = line[12:16]
                molecule_name = line[17:20]
                molecule_index = int(line[22:26]) - 1
                atom_x, atom_y, atom_z = (float(line[30:38]) / 10., float(line[38:46]) / 10., float(line[46:54]) / 10.)
                atom_element = line[76:78].strip()

                if not molecules:
                    molecules.append(Molecule(molecule_name, molecule_index, resname=molecule_name))
                elif molecules[-1]._index < molecule_index:
                    molecules.append(Molecule(molecule_name, molecule_index, resname=molecule_name))

                for molecule in molecules:
                    if molecule_index == molecule._index:
                        #molecule._atoms.append(Atom(index=atom_index, label=atom_label, ff_type=None, atomtype=None,
                        #                            coordinates=[atom_x, atom_y, atom_z], element=atom_element,
                        #                            bonds=None))
                        molecule._atoms.append(Atom(atom_label, atom_index=atom_index, atomtype=None,
                                                    coordinates=[atom_x, atom_y, atom_z], element=atom_element))
                        

            elif line.startswith("CONECT"):
                cols=line.split()
                atom_index=int(cols[1])-1
                bonds_imported = True
                bonds=[]
                for icol in range(2,len(cols)):
                    bonds.append(int(cols[icol])-1)

                
                for imol in range(prev_mol,len(molecules)):
                    break_again=False
                    molecule=molecules[imol]
                    molecule._natoms = len(molecule._atoms)
                    for atom in molecule._atoms:
                        if atom_index == atom._index:
                            #print(imol,atom_index,bonds)
                            atom._bonds = bonds
                            prev_mol=imol
                            break_again=True
                            break
                    if break_again:
                        break
                            
        file_pdb.close()

        # Import atomtypes (and eventually bonds) from .ac file
        if not bonds_imported:
            print("Something is wrong with the PDB file: No bonds found.\n"
                  "Try to generate a structure.ac file with the ambertool 'atomtype' or 'antechamber' and rerun "
                  "with the parameter 'include_atomtype=True'.")
            return

        
        # Check if molecule contains more than one component.
        molecules = System._arrange_atoms_in_molecules(molecules)

        return molecules

    @staticmethod
    def _arrange_atoms_in_molecules(molecules: list):
        """
        Check if the atoms in a Molecule object belongs to a single molecule. This is done to prevent errors from
        openbabel or the CSD Python API when assigning residues index. The check is performed by converting molecules to
        graphs and looking at their edges with the Breadth First Search algorithm.
        :param molecules: List of Molecule objects
        :return:
        """
        from scipy.sparse import csr_matrix
        from scipy.sparse.csgraph import breadth_first_order
        new_molecules = list()
        molidx = 0
        for molecule in molecules:
            graph = csr_matrix(molecule.contact_matrix)
            removed = []
            for atom in range(len(molecule._atoms)):
                if atom in removed:
                    continue

                bfs = breadth_first_order(graph, atom, False, False)
                removed = removed + list(bfs)
                new_molecule = Molecule(molecule._resname)
                new_molecule._index = molidx
                molidx += 1
                new_molecule._atoms = [molecule._atoms[i] for i in range(len(molecule._atoms)) if i in bfs]
                new_molecule._natoms = len(new_molecule._atoms)
                for natom in new_molecule._atoms:
                    natom._index = natom._index - (new_molecule._natoms * new_molecule._index)
                    natom._bonds = [bond - (new_molecule._natoms * new_molecule._index) for bond in natom._bonds]

                #new_molecule._calculate_centroid()
                #new_molecule._forcefield = molecule._forcefield
                #new_molecule._potential_energy = molecule._potential_energy
                #new_molecule._generate_contact_matrix()

                new_molecules.append(new_molecule)
        return new_molecules        

    def delete_molecules(self,delete_indexes):

        """Keep some molecule objects and delete the rest from the system object.
  
        :parm keep_indexes: list of molecule indexes correspondent to Molecule().index values
        """

        kept_molecules=[]
        
        for im,m in enumerate(self.molecules):
            if m.index not in delete_indexes:
                kept_molecules.append(m)

        self._molecules=kept_molecules
        
        for im,m in enumerate(self._molecules):
            #print(m.index)
            m.index=im
                

        

    #################
        

    def addBox(self,box_side: float, shape='cubic', output='box.pdb'):
        """ Create simulation box.
 
        Args: 
           box_side (float): side of the box in nm.
           shape (str, optional): shape of the box. Defaults to 'cubic'.
        """

        self.boxshape=shape
        
        if shape=='cubic':
            self.box=[box_side]*3+[90.0]*3
        elif shape=='dodecahedron':
            self.box=[box_side, box_side, 0.5*np.sqrt(2)*box_side] + [60.0]*3 # see Gromacs manual
        elif shape=='octahedron':
            self.box=[box_side, 2/3*np.sqrt(2)*box_side, 1/3*np.sqrt(6)*box_side]+[71.53, 109.47, 71.53] # see Gromacs manual
        else:
            # custom shape
            if len(box_side)!=6:
                print("ERROR: for custom boxes, box_side must be a list of 6 values ([a,b,c,alpha,beta,gamma])")
                exit()
            self.box=box_side

        with open(self.path+'/{}'.format(output),'w') as f:
            f.write('REMARK    THIS IS A SIMULATION BOX\n')
            f.write('CRYST1{:9.3f}{:9.3f}{:9.3f}{:7.2f}{:7.2f}{:7.2f}\n'.format(self.box[0]*10,
                                                                                self.box[1]*10,
                                                                                self.box[2]*10,
                                                                                self.box[3],
                                                                                self.box[4],
                                                                                self.box[5]))
            f.write('MODEL        1\nTER\nENDMDL\n')

        self.structure=self.path+'/{}'.format(output)

            
    def createSolventBox(self, solvent: object, output_structure="solvent_box.pdb", density=None, nmols=None):
        """ Add solvent molecules to the simulation box.
 
        Args: 
           solvent (Molecule() object) : molecule species to be used as solvent.
           output_structure (str, optional) : name of the structure file with the solvent box. Defaults to 'solvent_box.pdb'.
           density (float, optional) : desired density of solvent molecules in [g/L]. Defaults to None.
           nmols (int, optional) : desired number of solvent molecules. Defaults to None. If both density and number of molecules are provided, the size of the box is changed.
        """
        if (density is not None) and (nmols is not None):
            
            volume_box=solvent.mw*10/(density*6.022)*nmol
            self.box[0]=volume_box**(1/3)
            print("Both density and nmol have been defined: changing side of the box to {}.".format(self.box[0]))

        else:
            if self.boxshape=='cubic':
                volume_box=self.box[0]**3
            elif self.boxshape=='dodecahedron':
                volume_box=0.5*np.sqrt(2)*self.box[0]**3
            elif self.boxshape=='octahedron':
                volume_box=4/9*np.sqrt(3)*self.box[0]**3

        print(solvent.mw)
        nmols=util.estimateNumMolecules(volume_box,solvent.mw,density)-1
        
        os.system("{0} -nobackup editconf -f {1} -o {2} -box {3} -bt {4}  -c".format(self.gromacs,solvent.structure_path,
                                                                                     output_structure,
                                                                                     self.box[0],
                                                                                     self.boxshape))
               
        os.system("{0} -nobackup insert-molecules -f {1} -o {1} -ci {1} -nmol {2} -try 20000".format(self.gromacs,output_structure,
                                                                        nmols))

        inserted_mols=util.countMolecules(output_structure,solvent)

        if inserted_mols!=(nmols+1):
            print("Error! Inserted number of mol{} molecules required, but after {} trials only {} where inserted!".format(nmols, 20000, inserted_mols))
            exit()

        solvent.nmols=nmols

        self._updateComposition()


        
    def insertSolute(self, solute: object ,solvent: object, solvent_box="solvent_box.pdb", concentration=0.,
                     output_structure="start.pdb"):
        """ Insert solute molecules in the simulation box.

        Args: 
           solute (Molecule() object) : molecule type to be used as solute.
           solvent (Molecule() object) : molecule type to be used as solvent. 
           solvent_box (str, optional) : structure file where to add solute molecules. Defaults to 'solvent_box.pdb'.
           concentration (float, optional) : desired concentration of solute molecules in [g/L]. A density of 0 is a flag for simulations of dilute systems with only 1 solute molecule.
           output_structure (str, optional) : structure file where to save the final configuration. Defaults to 'start.pdb'.
        """
        
        if concentration == 0:
            # then single molecule
            nmols=1
        elif concentration > 0:
            from math import ceil
            nmols=util.estimateNumMolecules( self.box[0]**3,solute.mw,concentration )

        os.system("{0} insert-molecules -f {1} -o {2} -ci {3} -nmol {4} -try 10000 -replace {5} ".format( self.gromacs,
                                                                                                          solvent_box,
                                                                                                          output_structure,
                                                                                                          solute.structure_path,
                                                                                                          nmols,
                                                                                                          solvent.resname))

        inserted_mols=util.countMolecules(output_structure,solute)

        if inserted_mols!=nmols:
            print("Error! Inserted number of mol{} molecules required, but after {} trials only {} where inserted!".format(nmols, 10000, inserted_mols))
            exit()

        solvent.nmols=util.countMolecules(output_structure,solvent)
        solute.nmols=nmols
        self._updateComposition()

    def writeTop(self,atomtypes_path: str): #, *molecules: object):
        """ Write the topology file in Gromacs format)

        Args: 
            atomtypes_path (str) : path of the file with the atomtypes definition in Gromacs format.
        """

        with open(self.path+'/topol.top','w') as top:

            top.write(";\n\
; Topology for system {}\n\
;\n\n".format(self.name))

            top.write("[ defaults ]\n\
; nbfunc        comb-rule       gen-pairs       fudgeLJ fudgeQQ\n\
1               2               yes             0.5          0.83333333  \n\
\n\
[ atomtypes ]\n\
; name    at.num    mass    charge ptype  sigma      epsilon\n")

            with open(atomtypes_path,'r') as af:
                for line in af:
                    top.write(line)

            top.write("\n\n")

            for mol in self.molecules:
                with open(mol.include_path,'r') as itp:
                    top.write(";\n; {}\n;\n".format(mol.name))
                    for line in itp:
                        top.write(line)
                top.write("\n\n")

            top.write("[ system ]\n; Name\nA bunch of molecules floating around without rhyme or reason\n\n")

            top.write("[ molecules ]\n")
            
            for mol in self.molecules:
                top.write("{0}\t{1}\n".format(mol.resname,mol.nmols))

            

    def add_simulation(self, name: str, simtype: str, mdrun_options='', mdp='', print_bash=True,
                       maxwarn=0, start_coord='', plumed=None):
        """ Add a simulation to the system.
         
        Args: 
           name (str) : name of the simulation.
           simtype (str) : type of simulation to be run.
           mdrun_options (str, optional) : optional flags to be added to the mdrun command. Defaults to ''.
           mdp (str, optional) : name of the custom mdp file to use. Defaults to ''.
           print_bash (bool, optional) : generate a bash command to launch the simulation. Defaults to True.
           maxwarn (int, optional) : maximum number of warnings for grompp. Defaults to 0.
           start_coord (str, optional) : starting configuration of the simulation. Defaults to ''.
           plumed (str, optional) : plumed file to be used in the simulation. Defaults to None.

        Returns:
          sim : Simulation() object.
        """
       
        import sim_launch_py.gromacs as gmx

        accepted_types=['em','md']
        
        if start_coord=='':
            if len(self.simulations)>0:
                prev_sim=self.simulations[-1].name
            else:
                print("ERROR: 	For the first simulation of the system you need to specify the name of the starting configuration!")
                exit()
            start_coord=self.path+'/'+prev_sim+'.gro'
        else:
            start_coord=os.path.abspath(start_coord)
                
        if simtype=='md':
            if len(self.simulations)>0:
                prev_sim=self.simulations[-1].name
            elif len(self.simulations)==0:
                prev_sim='start'
            sim=gmx.MD(name,
                       mdrun_options=mdrun_options, coord=start_coord, topology=self.path+'/topol.top',
                       path_mdp=mdp, maxwarn=maxwarn,
                       path_input=self.path,path_output=self.path,print_bash=True,gmxbin=self.gromacs,plumed=plumed)
            
        elif simtype=='em':
            sim=gmx.EnergyMinimization(name,
                                       mdrun_options=mdrun_options, coord=start_coord, topology=self.path+'/topol.top',
                                       path_mdp=mdp, maxwarn=maxwarn,
                                       path_input=self.path,path_output=self.path,print_bash=True, gmxbin=self.gromacs)
        #elif simtype=='wtmetad':
        #    sim=gmx.WTMD(name='wtmd')
        else:
            print("Error: simulation type not recognized, accepted types are {}, your input was {}.".format(accepted_types,simtype))
            exit()

        self.simulations.append(sim)

        return sim

    def setSimsToRun(self, sims_to_run: list):
        """ Define which simulations in a system are to be run.

        Args:
           sims_to_run (Simulation objects): list of simulations to run.
        """
        for sim in self.simulations:
            sim.run=False

        for sim in sims_to_run:
            sim.run=True
            
    
    def print_command(self, bash_file: str):
        """ Print bash script to run the simulations of the system.

        Args:
           bash_file (str): name of the bash file.
        """

        bash_file=self.path+'/'+bash_file

        with open(bash_file,'w') as f:
            f.write("#!/bin/bash\n\n")
            for s in self.simulations:
                f.write("# {}\n".format(s.name))
                f.write(s.bash_command+'\n\n')


    def _updateComposition(self):
        """ Update the composition attribute, the atoms and the number of atoms in the system.
        """

        import copy
        
        self.composition=[0 for mol in self.molecules]
        self._atoms=[]

        for imol,mol in enumerate(self.molecules):
            self.composition[imol]=mol.nmols
            for i in range(mol.nmols):
                for iatom,atom in enumerate(mol.atoms):
                    new_atom=copy.deepcopy(mol.atoms[iatom])
                    self._atoms.append(new_atom)

        self._natoms=len(self._atoms)
        self._updateAtomID()
        

    def _updateAtomID(self):
        """ Update the atom ID of the atoms composing the system.
        """

        iatom=0
        molatom=0
        
        for imol,mol in enumerate(self.molecules):
            for n in range(self.composition[imol]):
                for i in range(mol._natoms):
                    self._atoms[iatom]._atomID=iatom+1
                    mol._atoms[molatom]._atomID=iatom+1
                    iatom+=1
                    molatom+=1
                molatom=0
                
            

class Molecule():
    """The molecule class that stores and manage all the information and methods.

    Attributes:
       name : name of the molecule type
       resname : residue name
       structure_path : location of the structure of the molecule type
       topology_path : location of the topology (.top) file of the molecule type
       include_path : location of the include topology (.itp) file of the molecule type 
       mw : molecular weight in [g/mol]
       mol_attributes : arbitrary attributes of the molecule
       nmols : number of molecules of this type
       natoms : number of atoms per molecule 
       atoms : list of atom types of the molecule type

    Methods:
       help(): print the help for this class.
    """


    def __init__(self,name: str, index=None, resname='UNK', structure=None):
        """Molecule Class Constructor
  
        Args: 
           name (str) : name of the molecule
           resname (str, optional) : residue name for the molecule. Defaults to 'UNK'.
           structure_path (str, optional) : position of the structure file. Defaults to None.
        """

        self._name=name
        self._resname=resname
        self._structure_path=structure
        self._topology_path=None
        self._include_path=None
        self._mw=None
        self._mol_attributes=[]
        self._nmols=0
        self._natoms=0
        self._atoms=list()
        self._index=index
        self._contact_matrix=None

        if structure is not None:

            import MDAnalysis as mda
            import warnings
            warnings.filterwarnings('ignore')

            u=mda.Universe(structure)
            self._natoms=u.atoms.n_atoms
            self._mw=0
            for iatom in range(self._natoms):

                new_atom=Atom(u.atoms.names[iatom],atom_index=u.atoms.ids[iatom],resname=resname,
                              mass=u.atoms.masses[iatom],element=u.atoms.types[iatom],coordinates=u.atoms.positions[iatom])
                                
                self._mw+=u.atoms.masses[iatom]
                self._atoms.append(new_atom)


    @property
    def name(self):
        return self._name

    @property
    def resname(self):
        return self._resname

    @property
    def structure_path(self):
        return self._structure_path

    @property
    def topology_path(self):
        return self._topology_path

    @property
    def include_path(self):
        return self._include_path

    @property
    def mw(self):
        if self._mw is None:
            self._mw=self._calc_mass(self.atoms)
        return self._mw

    @property
    def mol_attributes(self):
        return self._mol_attributes

    @property
    def natoms(self):
        return self._natoms

    @property
    def nmols(self):
        return self._nmols

    @property
    def atoms(self):
        return self._atoms

    @property
    def contact_matrix(self):
        if self._contact_matrix is None:
            self._generate_contact_matrix()
            return self._contact_matrix
        else:
            return self._contact_matrix    

    @property
    def index(self):
        return self._index
    
    @resname.setter
    def resname(self,resname):
        self._resname=resname

    @structure_path.setter
    def structure_path(self,path):
        self._structure_path=path

    @topology_path.setter
    def topology_path(self,path):
        self._topology_path=path

    @include_path.setter
    def include_path(self,path):
        self._include_path=path

    @mw.setter
    def mw(self,mw):
        self._mw=mw

    @mol_attributes.setter
    def mol_attributes(self,attr):
        self._mol_attributes.append(attr)

    @natoms.setter
    def natoms(self,n):
        self._natoms=n

    @nmols.setter
    def nmols(self,n):
        self._nmols=n

    @index.setter
    def index(self,ndx):
        self._index=ndx

    def _generate_contact_matrix(self):
        """
        Generate a NxN matrix (with N=number of atoms) with 1 elements if atoms are bonded and 0 if not.
        """
        cmat = np.full((len(self._atoms), len(self._atoms)), 0)
        for ai in range(len(self._atoms)):
            atom = self._atoms[ai]
            for bond in atom._bonds:
                #print(ai,self._atoms[ai].index, atom.bonds, bond,  min([i._index for i in self._atoms]),[i._index for i in self._atoms])
                aj = bond - min([i._index for i in self._atoms])
                #print(ai,aj)
                cmat[ai, aj] = 1
        self._contact_matrix = cmat

    def get_molecule_com(self,box,ignore_masses=False):
        """ Compute the center of mass (COM) of a molecule object
            :parm molecule: Molecule object.
            :parm box: Box parameters.
            :parm ignore_masses: if True the center of geometry (COG) is returned. Defaults to False.

            Returns:
            com: coordinates of COM/COG
            """

        com=[0,0,0]
        den=0

        pbc_coords=self.wrap_pbc(box)

        for iatom,atom in enumerate(self.atoms):
            for i in range(3):
                if ignore_masses:
                    com[i]+=pbc_coords[iatom][i]               
                else:
                    com[i]+=pbc_coords[iatom][i]*atom.mass


        if ignore_masses:
            den=len(self.atoms)
        else:
            den=self.mw

        com=[x/den for x in com]

        return com


    def wrap_pbc(self,box):

        """ Recompute coordinates of the molecule in order to make broken molecules whole 
        :parm molecule: Molecule object
        :parm box: list of 6 elements with box parameters ([a, b, c, alpha, beta, gamma])

        Returns:
        pbc_coords: coordinates of the molecule made whole
        """

        # the first atom of the molecule is taken as reference (even if it is not inside the box)

        import numpy as np

        n2=(np.cos(box[3])-np.cos(box[5])*np.cos(box[4]))/np.sin(box[5])
        M=np.array([[1, 0, 0],
                    [np.cos(box[5]), np.sin(box[5]), 0],
                    [np.cos(box[4]), n2, np.sqrt(np.sin(box[4])**2-n2*n2)]])

        M_inv=np.linalg.inv(M)

        pbc_coords=[a.coordinates for a in self.atoms]

        #print(pbc_coords)

        temp_coords=[]
        for iatom,atom in enumerate(self.atoms):
            temp_coords.append(M_inv.dot(atom.coordinates))

        for iatom,atom in enumerate(self.atoms):
            sij=temp_coords[iatom]-temp_coords[0]
            sij-=np.rint(sij)
            rij=M.dot(sij)

            pbc_coords[iatom]=rij+self.atoms[0].coordinates

        return pbc_coords
            
    @staticmethod
    def _calc_mass(atoms):
        mw=0
        for ia,a in enumerate(atoms):
            mw+=a.mass
        return mw
        
    @staticmethod
    def help():
        print("""Attributes:
       name : name of the molecule type
       resname : residue name
       structure_path : location of the structure of the molecule type
       topology_path : location of the topology (.top) file of the molecule type
       include_path : location of the include topology (.itp) file of the molecule type 
       mw : molecular weight in [g/mol]
       mol_attributes : arbitrary attributes of the molecule
       nmols : number of molecules of this type
       natoms : number of atoms per molecule 
       atoms : list of atom types of the molecule type

Methods:
       help(): print the help for this class.
    """)

 
class Atom():
    """
    The atom class that stores and manage all the information and methods.

    Attributes:
       name (str) : name of the atom.
       mass (float) : atomic mass.
       atomtype (str) : atom type.
       atom_index (int) : atom index.
       resnum (int) : number of the residue the atom is part of.
       resname (str) : name of the residue the atom is part of.
       element (str) : chemical element of the atom.
    """
    def __init__(self,name: str, mass=None, atomtype=None, atom_index=0, resname=None, element=None, coordinates=list()):
        """Atom Class Constructor

        Args:
            name (str): Atom name. Defaults to None.
            mass (float, optional): Mass of the atom. Defaults to None.
            atomtype (str, optional): AtomType of the atom. Defaults to None.
            atom_index (int, optional): AtomID of the atom. Defaults to 0.
            resnum (int, optional): Residue Number of the atom. Defaults to 0.
            resname (str, optional): Residue Name of the atom. Defaults to None.
            element (str, optional): Element of the atom. Defaults to None.
            coordinates (list, optional): Coordinates of the atom. Defaults to None.
        """

        self._name=name
        self._mass=mass
        self._atomtype=atomtype
        self._index=atom_index
        self._element=element
        self._coordinates=coordinates
        self._bonds=list()
    
    @property
    def name(self):
        return self._name

    @property
    def mass(self):
        if self._mass is None:
            self._mass=self._assign_mass(self._element)
        return self._mass

    @property
    def atomtype(self):
        return self._atomtype

    @property
    def index(self):
        return self._index

    @property
    def element(self):
        return self._element

    @property
    def coordinates(self):
        return self._coordinates

    @property
    def bonds(self):
        return self._bonds

    @name.setter
    def name(self,n):
        self._name=n

    @mass.setter
    def mass(self,mw):
        self._mass=mw

    @atomtype.setter
    def atomtype(self,atype):
        self._atomtype=atype

    @index.setter
    def atom_index(self,aid):
        self._index=aid

    @element.setter
    def element(self,el):
        self._element=el

    @coordinates.setter
    def coordinates(self,r):
        self._coordinates=r

    @bonds.setter
    def bonds(self,b):
        self._bonds=b

    @staticmethod
    def _assign_mass(element):

        masses={'H':1.0079,
                'C':12.0107,
                'N':14.0067,
                'O':15.9994,
                'F':18.9984,
                'S':32.065,
                'Cl':35.453,
                }

        if element in masses:
            return masses[element]
        else:
            print('WARNING: element not found, check and in case add it manually!')
            return None
